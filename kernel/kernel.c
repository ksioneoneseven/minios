/*
 * MiniOS Kernel Main Entry Point
 * 
 * This is the first C code executed after the bootloader.
 * It initializes all kernel subsystems and starts the first process.
 */

#include "include/types.h"
#include "include/multiboot.h"
#include "include/vga.h"
#include "include/string.h"
#include "include/gdt.h"
#include "include/idt.h"
#include "include/isr.h"
#include "include/pic.h"
#include "include/stdio.h"
#include "include/keyboard.h"
#include "include/timer.h"
#include "include/pmm.h"
#include "include/paging.h"
#include "include/heap.h"
#include "include/process.h"
#include "include/scheduler.h"
#include "include/syscall.h"
#include "include/vfs.h"
#include "include/ramfs.h"
#include "include/shell.h"
#include "include/loader.h"
#include "include/user.h"
#include "include/daemon.h"
#include "include/pagefault.h"
#include "include/ata.h"
#include "include/blockdev.h"
#include "include/ext2.h"
#include "include/vesa.h"
#include "include/xgui/xgui.h"
#include "include/serial.h"
#include "include/rtc.h"

/* Kernel end symbol from linker script */
extern uint32_t _kernel_end;

/*
 * Embedded userland binaries (from objcopy)
 * These symbols are generated by objcopy when converting ELFs to objects
 */
extern uint8_t _binary_shell_start[];
extern uint8_t _binary_shell_end[];
extern uint8_t _binary_init_start[];
extern uint8_t _binary_init_end[];

/* Helper to get embedded binary sizes */
static uint32_t get_shell_size(void) {
    return (uint32_t)((uint8_t*)&_binary_shell_end - (uint8_t*)&_binary_shell_start);
}

static uint32_t get_init_size(void) {
    return (uint32_t)((uint8_t*)&_binary_init_end - (uint8_t*)&_binary_init_start);
}

/* Check if a flag is present in the kernel command line */
static bool cmdline_has_flag(multiboot_info_t* mboot, const char* flag) {
    if (!(mboot->flags & MULTIBOOT_INFO_CMDLINE) || mboot->cmdline == 0) {
        return false;
    }
    const char* cmdline = (const char*)mboot->cmdline;
    const char* p = cmdline;
    size_t flag_len = strlen(flag);
    while (*p) {
        /* Skip whitespace */
        while (*p == ' ') p++;
        if (*p == '\0') break;
        /* Check if this token matches the flag */
        const char* token_start = p;
        while (*p && *p != ' ') p++;
        size_t token_len = p - token_start;
        if (token_len == flag_len && strncmp(token_start, flag, flag_len) == 0) {
            return true;
        }
    }
    return false;
}

/*
 * Print a hexadecimal number
 */
static void print_hex(uint32_t num) {
    char hex_chars[] = "0123456789ABCDEF";
    char buffer[11] = "0x00000000";
    
    for (int i = 9; i >= 2; i--) {
        buffer[i] = hex_chars[num & 0xF];
        num >>= 4;
    }
    
    vga_puts(buffer);
}

/*
 * Print memory information from multiboot
 */
static void print_memory_info(multiboot_info_t* mboot) {
    if (mboot->flags & MULTIBOOT_INFO_MEMORY) {
        vga_puts("  Lower memory: ");
        print_hex(mboot->mem_lower);
        vga_puts(" KB\n");
        
        vga_puts("  Upper memory: ");
        print_hex(mboot->mem_upper);
        vga_puts(" KB\n");
        
        uint32_t total_mb = (mboot->mem_lower + mboot->mem_upper) / 1024;
        vga_puts("  Total: ~");
        print_hex(total_mb);
        vga_puts(" MB\n");
    }
}

/*
 * Parse /etc/fstab and auto-mount filesystems
 * Format: device mountpoint fstype options (space-separated)
 * Lines starting with # are comments
 */
static void parse_fstab(void) {
    vfs_node_t* fstab = vfs_lookup("/etc/fstab");
    if (!fstab) {
        return;
    }

    /* Read fstab contents */
    uint8_t buf[512];
    int32_t len = vfs_read(fstab, 0, sizeof(buf) - 1, buf);
    if (len <= 0) {
        return;
    }
    buf[len] = '\0';

    /* Parse line by line */
    char* line = (char*)buf;
    while (*line) {
        /* Skip leading whitespace */
        while (*line == ' ' || *line == '\t') line++;

        /* Skip comments and empty lines */
        if (*line == '#' || *line == '\n' || *line == '\0') {
            while (*line && *line != '\n') line++;
            if (*line == '\n') line++;
            continue;
        }

        /* Parse: device mountpoint fstype */
        char device[32] = {0};
        char mountpoint[64] = {0};
        char fstype[16] = {0};

        int i = 0;
        /* Device */
        while (*line && *line != ' ' && *line != '\t' && *line != '\n' && i < 31) {
            device[i++] = *line++;
        }
        device[i] = '\0';

        /* Skip whitespace */
        while (*line == ' ' || *line == '\t') line++;

        /* Mountpoint */
        i = 0;
        while (*line && *line != ' ' && *line != '\t' && *line != '\n' && i < 63) {
            mountpoint[i++] = *line++;
        }
        mountpoint[i] = '\0';

        /* Skip whitespace */
        while (*line == ' ' || *line == '\t') line++;

        /* Filesystem type */
        i = 0;
        while (*line && *line != ' ' && *line != '\t' && *line != '\n' && i < 15) {
            fstype[i++] = *line++;
        }
        fstype[i] = '\0';

        /* Skip to end of line */
        while (*line && *line != '\n') line++;
        if (*line == '\n') line++;

        /* Validate and mount */
        if (device[0] && mountpoint[0] && fstype[0]) {
            /* Only ext2 supported for now */
            if (strcmp(fstype, "ext2") == 0) {
                blockdev_t* bdev = blockdev_get_by_name(device);
                if (bdev) {
                    /* Check if mountpoint exists, create if not */
                    vfs_node_t* mp = vfs_lookup(mountpoint);
                    if (!mp) {
                        /* Try to create the mountpoint directory */
                        if (mountpoint[0] == '/' && mountpoint[1] != '\0') {
                            ramfs_create_dir(mountpoint + 1);
                            mp = vfs_lookup(mountpoint);
                        }
                    }

                    if (mp) {
                        vfs_node_t* root = ext2_mount(bdev);
                        if (root) {
                            if (vfs_mount(mountpoint, root) == 0) {
                                printk("fstab: mounted %s on %s (%s)\n", device, mountpoint, fstype);
                            }
                        }
                    }
                }
            }
        }
    }
}

/*
 * Kernel main entry point
 * Called from boot.asm with multiboot info
 */
void kernel_main(uint32_t magic, multiboot_info_t* mboot) {
    /* Serial first (useful for debugging graphics-mode boots) */
    serial_init();
    serial_write_string("MiniOS: kernel_main entry\n");

    /* Initialize VGA driver first so we can output text */
    vga_init();
    serial_write_string("MiniOS: vga_init done\n");
    
    /* Print banner */
    vga_write("=====================================\n", 
              vga_entry_color(VGA_COLOR_LIGHT_CYAN, VGA_COLOR_BLACK));
    vga_write("        MiniOS v0.1 Booting...       \n",
              vga_entry_color(VGA_COLOR_WHITE, VGA_COLOR_BLACK));
    vga_write("=====================================\n\n",
              vga_entry_color(VGA_COLOR_LIGHT_CYAN, VGA_COLOR_BLACK));
    
    /* Verify multiboot magic number */
    if (magic != MULTIBOOT_BOOTLOADER_MAGIC) {
        serial_write_string("MiniOS: invalid multiboot magic: ");
        serial_write_hex(magic);
        serial_write_string("\n");
        vga_write("[FAIL] ", vga_entry_color(VGA_COLOR_LIGHT_RED, VGA_COLOR_BLACK));
        vga_puts("Invalid multiboot magic number!\n");
        vga_puts("  Expected: ");
        print_hex(MULTIBOOT_BOOTLOADER_MAGIC);
        vga_puts("\n  Got:      ");
        print_hex(magic);
        vga_puts("\n");
        return;
    }
    
    vga_write("[ OK ] ", vga_entry_color(VGA_COLOR_LIGHT_GREEN, VGA_COLOR_BLACK));
    vga_puts("Multiboot magic verified\n");
    serial_write_string("MiniOS: multiboot magic verified\n");

    if (mboot) {
        serial_write_string("MiniOS: multiboot flags=");
        serial_write_hex(mboot->flags);
        serial_write_string("\n");
    } else {
        serial_write_string("MiniOS: multiboot info ptr is NULL\n");
    }

    /* Initialize GDT */
    gdt_init();
    vga_write("[ OK ] ", vga_entry_color(VGA_COLOR_LIGHT_GREEN, VGA_COLOR_BLACK));
    vga_puts("GDT initialized\n");

    /* Initialize FPU (x87) â€” clear EM and TS bits in CR0, then fninit */
    __asm__ volatile(
        "mov %%cr0, %%eax\n"
        "and $0xFFFFFFF9, %%eax\n"  /* Clear EM (bit 2) and TS (bit 3) */
        "or  $0x00000002, %%eax\n"  /* Set MP (bit 1) */
        "mov %%eax, %%cr0\n"
        "fninit\n"
        ::: "eax"
    );
    vga_write("[ OK ] ", vga_entry_color(VGA_COLOR_LIGHT_GREEN, VGA_COLOR_BLACK));
    vga_puts("FPU initialized\n");

    /* Initialize ISR system */
    isr_init();

    /* Initialize IRQ system (includes PIC) */
    irq_init();

    /* Initialize IDT */
    idt_init();
    vga_write("[ OK ] ", vga_entry_color(VGA_COLOR_LIGHT_GREEN, VGA_COLOR_BLACK));
    vga_puts("IDT initialized\n");

    /* Enable interrupts */
    __asm__ volatile("sti");
    vga_write("[ OK ] ", vga_entry_color(VGA_COLOR_LIGHT_GREEN, VGA_COLOR_BLACK));
    vga_puts("Interrupts enabled\n");

    /* Initialize timer (100 Hz) */
    timer_init(100);
    vga_write("[ OK ] ", vga_entry_color(VGA_COLOR_LIGHT_GREEN, VGA_COLOR_BLACK));
    vga_puts("Timer initialized (100 Hz)\n");

    /* Initialize keyboard */
    keyboard_init();
    vga_write("[ OK ] ", vga_entry_color(VGA_COLOR_LIGHT_GREEN, VGA_COLOR_BLACK));
    vga_puts("Keyboard initialized\n");

    /* Initialize real-time clock */
    rtc_init();
    vga_write("[ OK ] ", vga_entry_color(VGA_COLOR_LIGHT_GREEN, VGA_COLOR_BLACK));
    vga_puts("RTC initialized\n");

    /* Initialize physical memory manager */
    vga_write("[ OK ] ", vga_entry_color(VGA_COLOR_LIGHT_GREEN, VGA_COLOR_BLACK));
    vga_puts("Initializing physical memory manager...\n");
    pmm_init(mboot, (uint32_t)&_kernel_end);

    /* Initialize paging (virtual memory) */
    vga_write("[ OK ] ", vga_entry_color(VGA_COLOR_LIGHT_GREEN, VGA_COLOR_BLACK));
    vga_puts("Initializing paging...\n");
    paging_init();

    /* Initialize page fault handler (enables graceful fault handling) */
    vga_write("[ OK ] ", vga_entry_color(VGA_COLOR_LIGHT_GREEN, VGA_COLOR_BLACK));
    vga_puts("Initializing page fault handler...\n");
    pagefault_init();

    /* Initialize kernel heap (start at 4MB, 1MB size) */
    vga_write("[ OK ] ", vga_entry_color(VGA_COLOR_LIGHT_GREEN, VGA_COLOR_BLACK));
    vga_puts("Initializing kernel heap...\n");
    heap_init(0x400000, HEAP_INITIAL_SIZE);

    /* Initialize scheduler (creates idle process) */
    vga_write("[ OK ] ", vga_entry_color(VGA_COLOR_LIGHT_GREEN, VGA_COLOR_BLACK));
    vga_puts("Initializing scheduler...\n");
    scheduler_init();

    /* Initialize system calls */
    vga_write("[ OK ] ", vga_entry_color(VGA_COLOR_LIGHT_GREEN, VGA_COLOR_BLACK));
    vga_puts("Initializing system calls...\n");
    syscall_init();

    /* Initialize block device layer */
    vga_write("[ OK ] ", vga_entry_color(VGA_COLOR_LIGHT_GREEN, VGA_COLOR_BLACK));
    vga_puts("Initializing block device layer...\n");
    blockdev_init();

    /* Initialize ATA disk driver */
    vga_write("[ OK ] ", vga_entry_color(VGA_COLOR_LIGHT_GREEN, VGA_COLOR_BLACK));
    vga_puts("Initializing ATA driver...\n");
    ata_init();

    /* Initialize VFS */
    vga_write("[ OK ] ", vga_entry_color(VGA_COLOR_LIGHT_GREEN, VGA_COLOR_BLACK));
    vga_puts("Initializing VFS...\n");
    vfs_init();

    /* Initialize and mount ramfs as root */
    vfs_node_t* ramfs_root = ramfs_init();
    vfs_mount("/", ramfs_root);

    /* Create some test files */
    vfs_node_t* test_file = ramfs_create_file("hello.txt", 0);
    if (test_file) {
        const char* hello = "Hello from MiniOS filesystem!\n";
        vfs_write(test_file, 0, strlen(hello), (uint8_t*)hello);
    }

    /* Create /bin directory and install userland binaries */
    vfs_node_t* bin_dir = ramfs_create_dir("bin");
    if (bin_dir) {
        /* Create other standard directories */
        ramfs_create_dir("home");
        ramfs_create_dir("etc");
        ramfs_create_dir("root");
        ramfs_create_dir("mnt");

        /* Create /etc/fstab for auto-mounting */
        vfs_node_t* etc_dir = vfs_lookup("/etc");
        if (etc_dir) {
            vfs_node_t* fstab = ramfs_create_file_in(etc_dir, "fstab", VFS_FILE);
            if (fstab) {
                const char* fstab_content = 
                    "# MiniOS fstab - filesystem table\n"
                    "# Format: device mountpoint fstype options\n"
                    "# Example: hd0p1 /mnt ext2 defaults\n"
                    "hd1p1 /mnt ext2 defaults\n";
                vfs_write(fstab, 0, strlen(fstab_content), (uint8_t*)fstab_content);
            }
        }

        uint32_t shell_size = get_shell_size();
        vga_write("[ OK ] ", vga_entry_color(VGA_COLOR_LIGHT_GREEN, VGA_COLOR_BLACK));
        vga_puts("Installing userland shell (");
        print_hex(shell_size);
        vga_puts(" bytes)...\n");

        vfs_node_t* shell_file = ramfs_create_file_in(bin_dir, "shell", VFS_FILE);
        if (shell_file) {
            /* Make it executable */
            shell_file->mode = 0755;
            vfs_write(shell_file, 0, shell_size, _binary_shell_start);
        }

        uint32_t init_size = get_init_size();
        vga_write("[ OK ] ", vga_entry_color(VGA_COLOR_LIGHT_GREEN, VGA_COLOR_BLACK));
        vga_puts("Installing init (");
        print_hex(init_size);
        vga_puts(" bytes)...\n");

        vfs_node_t* init_file = ramfs_create_file_in(bin_dir, "init", VFS_FILE);
        if (init_file) {
            init_file->mode = 0755;
            vfs_write(init_file, 0, init_size, _binary_init_start);
        }
    }

    /* Parse /etc/fstab and auto-mount filesystems */
    vga_write("[ OK ] ", vga_entry_color(VGA_COLOR_LIGHT_GREEN, VGA_COLOR_BLACK));
    vga_puts("Parsing /etc/fstab...\n");
    parse_fstab();

    /* Print bootloader info */
    if (mboot->flags & 0x200) {  /* Boot loader name flag */
        vga_write("[ OK ] ", vga_entry_color(VGA_COLOR_LIGHT_GREEN, VGA_COLOR_BLACK));
        vga_puts("Bootloader: ");
        vga_puts((const char*)mboot->boot_loader_name);
        vga_puts("\n");
    }

    /* Print memory information */
    vga_write("[ OK ] ", vga_entry_color(VGA_COLOR_LIGHT_GREEN, VGA_COLOR_BLACK));
    vga_puts("Memory detected:\n");
    print_memory_info(mboot);

    /* Boot complete message */
    vga_puts("\n");
    vga_write("=====================================\n",
              vga_entry_color(VGA_COLOR_LIGHT_CYAN, VGA_COLOR_BLACK));
    vga_write("     Kernel loaded successfully!     \n",
              vga_entry_color(VGA_COLOR_LIGHT_GREEN, VGA_COLOR_BLACK));
    vga_write("=====================================\n",
              vga_entry_color(VGA_COLOR_LIGHT_CYAN, VGA_COLOR_BLACK));

    vga_puts("\nPhase 12 Complete - System daemons ready!\n");

    /* Initialize program loader */
    loader_init();

    /* Initialize user subsystem (creates root and guest users) */
    user_init();

    /* Initialize daemon subsystem */
    daemon_init();

    /* Start all system daemons */
    daemon_start_all();

    /* Initialize kernel shell (still used for debug commands) */
    shell_init();

    /* ============================================================
     * STAGE 3: BOOT MODE SELECTION
     * ============================================================
     * Default: Run shell in kernel mode (Ring 0).
     * Use 'sandbox' command to run applications in Ring 3.
     * Use 'usermode' boot flag to launch init in Ring 3 by default.
     */
    vga_puts("\n");

    bool usermode_boot = cmdline_has_flag(mboot, "usermode");

    /* Check if we booted in VESA graphics mode - if so, start XGUI directly */
    serial_write_string("MiniOS: calling vesa_init()\n");
    vesa_init(mboot);
    serial_write_string("MiniOS: returned from vesa_init()\n");
    
    /* Debug: Try to draw something directly to framebuffer if VESA detected */
    if (vesa_available()) {
        serial_write_string("MiniOS: VESA available - drawing test rect and starting XGUI\n");
        vesa_fill_rect(0, 0, 100, 100, 0xFFFF0000);
        
        /* We're in graphics mode - start XGUI directly */
        xgui_run();
        
        /* If XGUI exits, halt (can't return to text mode) */
        while (1) {
            __asm__ volatile("hlt");
        }
    }

    serial_write_string("MiniOS: VESA not available - continuing text boot\n");

    if (!usermode_boot) {
        vga_write("=====================================\n",
                  vga_entry_color(VGA_COLOR_LIGHT_BROWN, VGA_COLOR_BLACK));
        vga_write("  Stage 3: Ring 0 Mode (Kernel Shell)\n",
                  vga_entry_color(VGA_COLOR_WHITE, VGA_COLOR_BLACK));
        vga_write("=====================================\n",
                  vga_entry_color(VGA_COLOR_LIGHT_BROWN, VGA_COLOR_BLACK));
        vga_write("[ OK ] ", vga_entry_color(VGA_COLOR_LIGHT_GREEN, VGA_COLOR_BLACK));
        vga_puts("Running kernel shell (Ring 0)...\n");
        vga_puts("Use 'sandbox <program>' to run in Ring 3\n\n");
        shell_run();
    } else {
        vga_write("=====================================\n",
                  vga_entry_color(VGA_COLOR_LIGHT_MAGENTA, VGA_COLOR_BLACK));
        vga_write("  Stage 3: Launching Init Process   \n",
                  vga_entry_color(VGA_COLOR_WHITE, VGA_COLOR_BLACK));
        vga_write("=====================================\n",
                  vga_entry_color(VGA_COLOR_LIGHT_MAGENTA, VGA_COLOR_BLACK));

        /* Launch init as the first user process */
        int init_pid = process_exec_elf("/bin/init");
        if (init_pid < 0) {
            vga_write("[FAIL] ", vga_entry_color(VGA_COLOR_LIGHT_RED, VGA_COLOR_BLACK));
            vga_puts("Failed to start init process!\n");
            vga_puts("Falling back to kernel shell...\n");
            shell_run();
        } else {
            vga_write("[ OK ] ", vga_entry_color(VGA_COLOR_LIGHT_GREEN, VGA_COLOR_BLACK));
            vga_puts("Init started (PID ");
            char buf[12];
            int i = 0, n = init_pid;
            do { buf[i++] = '0' + (n % 10); n /= 10; } while (n > 0);
            while (i > 0) vga_putchar(buf[--i]);
            vga_puts(")\n\n");

            /* Start the scheduler - this switches to the first ready process */
            extern void scheduler_start(void);
            scheduler_start();
        }
    }

    /* Should never reach here */
    while (1) {
        __asm__ volatile("hlt");
    }
}

